Ref: https://zokrates.github.io/examples/rng_tutorial.html#tutorial-a-snark-powered-rng

# Problem Statement
- There are 2 communicating players/users.
- Logic of Randomization: XOR of a 512 bit value submitted by both of the players. This 512 bit value is witness (ZKP terminology).
  - Assuming they both wants a fair competition, any of the player are not aware of other players 512 bit value "secret".
  - To ensure that players do not modify their 512 bit, the value is hashed and the hashed value is made public X (ZKP terminology).
- Process for generating a random number.
  - Before this, all players will share ZKP proof that they know about a 512 bit. The verifier needs to make sure that this claim is valid through the random number generation process. We want to raise red flags is any of the players sends any other bit other than what is calimed by proof.
  - player1 and player2 will submit 1 bit at every random number generation, the bit will be from the left side and sequentially progressing to the right side.
  - There will be a limit on amount of random numbers that can be generated, to prevent someone from guessing the rest of the remaining 512 bit value.

---
# Solution

## 1. Create a high level code of the ZKP using ZoKrates
- Create a ZoKrates code to create a hash of a 512 bit value. `get_hash.zok`
- The input is in form of a 16 times 32 bit value

## 2. Convert this high level code to ZKP usable "R1Cs format".
- `zokrates compile -i get_hash.zok -o get_hash && zokrates inspect -i get_hash`
- This will create `get_hash` file (without any extensions). The is similar to that of a binary file.

## 3. Send secret and execute the program
- This step is also called compute witness.
- We pass in the argument of the function `main()` and run the  `main()` function.
- For a secret value = `0x00000000000000010000000200000003000000040000000500000006...` so on till 512 bits, we need to convert these into chunks of 32 bits and convert these chunks into decimal. This will look like `0 1 2 3 4 5 6 ...` so on till `15`. These is the secret value which we dont want to show to anyone.
- This input we need to give to the `-a` parameter.
- `zokrates compute-witness --verbose -i get_hash -a 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15`
- Below is the output of the program
```
Computing witness...

Witness: 
["3592665057","2164530888","1223339564","3041196771","2006723467","2963045520","3851824201","3453903005"]

Witness file written to 'witness'
```

## 4. Working of ZKP
- Overall Approach
  - Both alice and bob will have the `reveal_bit.zok` file.
  - To ensure that alice does not tamper with `reveal_bit.zok` bob generates a proving.key and verification.key, this will ensure that the code is not changed by alice.
  - Using the below data, alice computes the proof `proof.json`
    - proving.key of bob
    - witness (secret) of alice
    - `reveal_bit.zok`
  - As bob's proving key was used to generate the proof, bob has a verification key to verify if his proving.key was indeed used to generate the `proof.json` file
    - Why this is needed?
    - The proving key is generated using `reveal_bit.zok` by bob because to check incase alice maliciously make any changes to the `reveal_bit.zok`.
    - Either Alice can use this proving.key or it can generate a new one without changing the `reveal_bit.zok` code. If Alice manipulates `reveal_bit.zok`, this will be flagged in verification check by bob.
    - This also means Alice cannot change the secret only during the first message, bob will also check if the hashed value is the same across all the messages. And indeed the hash message is generated by Alice using `reveal_bit.zok`. As the value returned is the "hash" and the value at the particular bit number.
    - `sha256(preimage[0..8], preimage[8..16]), preimageBits[bitNum]`
- Copy `reveal_bit.zok` in 2 folders named "alice" and "bob" which will be the two communicating players.
- Bob's Folder (side)
  - Details
  - Step 1: Compile `reveal_bit.zok`
    - `zokrates compile -i reveal_bit.zok -o reveal_bit`
  - Step 2: Generate the proving and verification keys using "setup" command.
    - `zokrates setup -i reveal_bit`
  - At this point "bob" has not commited its 512 bits.
    - Yes but note that this is `reveal_bit.zok` file not the `get_hash.zok` file which is where we need to supply the secret 512 bits.
  - Step 3: Finally copy the `proving.key` from Bob folder to Alice's folder. Why? will be explained later.
- Alice's Folder (side)
  - Details
  - Step 1: Compile `reveal_bit.zok`
    - `zokrates compile -i reveal_bit.zok -o reveal_bit`
  - Step 2: Send the witness and execute the code for Alice.
    - `zokrates compute-witness --verbose -i reveal_bit -a 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 510`
      - preimage/secret/witness : `0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15`
      - the bitnumber: `510`
      - The above are the two inputs needed for `reveal_bit.zok` file. `private u32[16] preimage, u32 bitNum`
  - Step 3: Generate proof
    - `zokrates generate-proof -i reveal_bit`
  - Step 3: Executing the above command will generate a `proof.json` file. This file is the final proof file of zkp using zokrates. Copy this file to bob's folder.
- Bob's Folder (side)
  - Bob will verify the `proof.json` file.
    - It needs the files "proof.json", "verification.key", "proving.key"
  - `zokrates verify`